var documenterSearchIndex = {"docs":
[{"location":"index.html#Slanter","page":"Slanter","title":"Slanter","text":"","category":"section"},{"location":"index.html#Slanter","page":"Slanter","title":"Slanter","text":"Reorder matrices rows and columns to move high values close to the diagonal.\n\n\n\n\n\n","category":"module"},{"location":"index.html#Slanter.slanted_orders","page":"Slanter","title":"Slanter.slanted_orders","text":"function slanted_orders(\n    data::AbstractMatrix{<:Real};\n    order_rows::Bool=true,\n    order_cols::Bool=true,\n    squared_order::Bool=true,\n    same_order::Bool=false,\n    discount_outliers::Bool=true,\n    max_spin_count::Integer=10\n)::Tuple{AbstractVector{<:Integer}, AbstractVector{<:Integer}}\n\nCompute rows and columns orders which move high values close to the diagonal.\n\nFor a matrix expressing the cross-similarity between two (possibly different) sets of entities, this produces better results than clustering. This is because clustering does not care about the order of each two sub-partitions. That is, clustering is as happy with ((2, 1), (4, 3)) as it is with the more sensible ((1, 2), (3, 4)). As a result, visualizations of similarities using naive clustering can be misleading.\n\nThis situation is worse in Python or R than it is in Julia, which mercifully provides the :barjoseph method to reorder the branches. Still, the method here may be \"more suitable\" in specific circumstances (when the data depicts a clear gradient).\n\nParameters\n\ndata: A rectangular matrix containing non-negative values (may be negative if squared_order).\norder_rows: Whether to reorder the rows.\norder_cols: Whether to reorder the columns.\nsquared_order: Whether to reorder to minimize the l2 norm (otherwise minimizes the l1 norm).\nsame_order: Whether to apply the same order to both rows and columns.\ndiscount_outliers: Whether to do a final order phase discounting outlier values far from the diagonal.\nmax_spin_count: How many times to retry improving the solution before giving up.\n\nReturns\n\nA tuple with two vectors, which contain the order of the rows and the columns.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Slanter.slanted_reorder","page":"Slanter","title":"Slanter.slanted_reorder","text":"slanted_reorder(\n    data::AbstractMatrix{T};\n    order_data::Union{AbstractMatrix{<:Real}, Nothing}=nothing,\n    order_rows::Bool=true,\n    order_cols::Bool=true,\n    squared_order::Bool=true,\n    same_order::Bool=false,\n    discount_outliers::Bool=true\n)::AbstractMatrix{T} where {T<:Real}\n\nReorder data rows and columns to move high values close to the diagonal.\n\nGiven a matrix expressing the cross-similarity between two (possibly different) sets of entities, this uses slanted_orders to compute the \"best\" order for visualizing the matrix, then returns the reordered data.\n\nParameters\n\ndata: A rectangular matrix to reorder, of non-negative values (unless order_data is specified, or squared_order)).\norder_data: An optional matrix of non-negative values of the same size to use for computing the orders (may be negative if squared_order).\norder_rows: Whether to reorder the rows.\norder_cols: Whether to reorder the columns.\nsquared_order: Whether to reorder to minimize the l2 norm (otherwise minimizes the l1 norm).\nsame_order: Whether to apply the same order to both rows and columns.\ndiscount_outliers: Whether to do a final order phase discounting outlier values far from the diagonal.\n\nReturns\n\nA matrix of the same shape whose rows and columns are a permutation of the input.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Slanter.reorder_hclust","page":"Slanter","title":"Slanter.reorder_hclust","text":"reorder_hclust(clusters, order)\n\nGiven a clustering of some data, and some ideal order we'd like to use to visualize it, reorder (but do not modify) the clustering to be as consistent as possible with this ideal order.\n\nParameters\n\nclusters: The existing clustering of the data.\norder: The ideal order we'd like to see the data in.\n\nReturns\n\nA reordered clustering which is consistent, wherever possible, with the ideal order.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Slanter.oclust","page":"Slanter","title":"Slanter.oclust","text":"oclust(distances; method=\"ward.D2\", order=nothing, members=nothing)\n\nHierarchically cluster ordered data.\n\nGiven a distance matrix for sorted objects, compute a hierarchical clustering preserving this order. That is, this is similar to hclust with the constraint that the result's order is always 1:N.\n\nIf an order is specified, assumes that the data will be re-ordered by this order. That is, the indices in the returned clustering object will refer to the post-reorder data locations, not to the current data locations.\n\nCurrently, the only methods supported are ward.D and ward.D2.\n\nParameters\n\ndistances: A distance matrix.\nmethod: The clustering method to use (only ward.D and ward.D2 are supported).\norder: If specified, assume the data will be re-ordered by this order.\nmembers: Optionally, the number of members for each row/column of the distances (by default, one each).\n\nReturns\n\nA clustering object (similar to R's hclust).\n\n\n\n\n\n","category":"function"},{"location":"index.html#Index","page":"Slanter","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Slanter","title":"Slanter","text":"","category":"page"}]
}
